<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pair Chat ‚Äî E2E + Images (Firestore) + TTL</title>
  <style>
    :root { --bg:#0f1220; --card:#171a2b; --text:#eef1ff; --muted:#aab0d6;
            --accent:#5c7cfa; --accent2:#748ffc; --danger:#ff6b6b; --ok:#51cf66;
            --shadow:0 10px 30px rgba(0,0,0,.35); }
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;
         background:radial-gradient(1200px 600px at 20% -10%,rgba(92,124,250,.18),transparent),
                    radial-gradient(1000px 500px at 100% 0,rgba(116,143,252,.14),transparent),var(--bg);
         color:var(--text)}
    .container{max-width:860px;margin:28px auto;padding:0 12px}
    h1{margin:0 0 14px}
    .card{background:var(--card);border:1px solid rgba(255,255,255,.06);border-radius:16px;padding:14px;margin:12px 0;box-shadow:var(--shadow)}
    .hint{margin:6px 0 0;color:var(--muted);font-style:italic}
    .code{font-family:ui-monospace,Menlo,Consolas,monospace;letter-spacing:1px;font-weight:700}
    .row{display:flex;gap:8px;align-items:center}
    .row-wrap{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .my-code-row{gap:12px;font-size:22px}
    input, select{flex:1;padding:11px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.12);
          background:rgba(255,255,255,.04);color:var(--text);outline:none}
    input::placeholder{color:#9aa2d1} input:focus, select:focus{border-color:var(--accent)}
    .btn{padding:10px 14px;border-radius:12px;border:1px solid transparent;
         background:linear-gradient(180deg,var(--accent),var(--accent2));color:#fff;font-weight:600;cursor:pointer}
    .btn:hover{filter:brightness(1.1)} .btn:active{transform:translateY(1px)}
    .btn-light{background:rgba(255,255,255,.08);border-color:rgba(255,255,255,.14)}
    .btn-danger{background:rgba(255,107,107,.18);border-color:rgba(255,107,107,.45);color:#fff}
    .error{color:var(--danger);min-height:20px;margin-top:8px}
    .ok{color:var(--ok)}
    .chat-header{display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:6px}
    .chat-actions{display:flex;gap:8px;align-items:center}
    .chat{display:grid;grid-template-rows:auto auto 1fr auto;height:60vh} /* –Ω–∏–∂–µ —Å—Ç–∞–ª–æ */
    .messages{list-style:none;padding:0;margin:0;overflow-y:auto;border:1px solid rgba(255,255,255,.08);
              border-radius:12px;background:rgba(255,255,255,.03)}
    .msg{max-width:80%;margin:8px;padding:10px 12px;border-radius:14px;line-height:1.25;
         border:1px solid rgba(255,255,255,.08);box-shadow:0 6px 14px rgba(0,0,0,.2);word-wrap:break-word}
    .msg.me{margin-left:auto;background:rgba(92,124,250,.18)}
    .msg.other{margin-right:auto;background:rgba(255,255,255,.06)}
    .msg-time{display:block;margin-top:6px;font-size:12px;color:var(--muted);text-align:right}
    .msg img{max-width:320px;border-radius:10px;display:block}
    .send-row{display:flex;gap:8px;margin-top:8px;position:sticky;bottom:0;z-index:2;
              background:rgba(15,18,32,.7);backdrop-filter:blur(6px);padding:8px;border-radius:12px;border:1px solid rgba(255,255,255,.06)}
    .hidden{display:none}
    .footer{text-align:center;color:var(--muted);margin-top:16px;font-size:12px}
    .small{font-size:12px;color:var(--muted)}
    .nowrap{white-space:nowrap}

    /* –ú–æ–±–∏–ª—å–Ω–∞—è –≤—ë—Ä—Å—Ç–∫–∞ */
    @media (max-width: 520px){
      .container{margin:16px auto;padding:0 10px}
      .chat{height:58vh}
      .msg img{max-width:70vw}
      .send-row{flex-direction:column; align-items:stretch}
      #imgInput{width:100%}
    }
  </style>
</head>
<body>
  <main class="container">
    <h1>Pair Chat</h1>

    <section class="card">
      <h2>–¢–≤–æ–π –∫–æ–¥</h2>
      <div class="row my-code-row">
        <span id="myCode" class="code">‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢</span>
        <button id="copyBtn" class="btn">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
      </div>
      <p class="hint">–û—Ç–ø—Ä–∞–≤—å —ç—Ç–æ—Ç 6-–∑–Ω–∞—á–Ω—ã–π –∫–æ–¥ –¥—Ä—É–≥—É. –ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —á–∞—Ç, –≤–≤–µ–¥–∏ –µ–≥–æ –∫–æ–¥ –Ω–∏–∂–µ.</p>
    </section>

    <section class="card">
      <h2>–ù–∞—á–∞—Ç—å —á–∞—Ç —Å –¥—Ä—É–≥–æ–º</h2>
      <form id="pairForm" class="row">
        <input id="friendCodeInput" maxlength="6" pattern="[0-9]{6}" placeholder="–ö–æ–¥ –¥—Ä—É–≥–∞ (6 —Ü–∏—Ñ—Ä)" required />
        <button class="btn" type="submit">–û—Ç–∫—Ä—ã—Ç—å —á–∞—Ç</button>
      </form>
      <p id="pairError" class="error"></p>
    </section>

    <section id="chatSection" class="card chat hidden">
      <div class="chat-header">
        <div>–ß–∞—Ç —Å –∫–æ–¥–æ–º: <span id="peerCode" class="code"></span></div>
        <div class="chat-actions">
          <div id="lockState" class="code ok">üîí –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –≤–∫–ª—é—á–µ–Ω–æ</div>
          <button id="wipeBtn" class="btn btn-danger" title="–£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è —á–∞—Ç–∞">–°—Ç–µ—Ä–µ—Ç—å –≤—Å—ë</button>
          <button id="closeChatBtn" class="btn btn-light">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
      </div>

      <div class="row-wrap" style="margin-bottom:6px">
        <label class="small nowrap" for="ttlSelect">–£–¥–∞–ª—è—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è —á–µ—Ä–µ–∑:</label>
        <select id="ttlSelect" style="max-width:260px">
          <option value="60" selected>1 –º–∏–Ω—É—Ç–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)</option>
          <option value="1800">30 –º–∏–Ω—É—Ç</option>
          <option value="3600">1 —á–∞—Å</option>
          <option value="25200">7 —á–∞—Å–æ–≤</option>
          <option value="259200">3 –¥–Ω—è</option>
          <option value="604800">7 –¥–Ω–µ–π</option>
        </select>
        <span id="ttlStatus" class="small"></span>
      </div>

      <ul id="messages" class="messages"></ul>

      <!-- –æ–¥–Ω–∞ –∫–Ω–æ–ø–∫–∞: —Ç–µ–∫—Å—Ç –∏/–∏–ª–∏ —Ñ–æ—Ç–æ -->
      <form id="msgForm" class="send-row">
        <input id="msgInput" placeholder="–ù–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ..." autocomplete="off" />
        <input id="imgInput" type="file" accept="image/*;capture=camera"
               style="flex:0 0 auto; width:240px; padding:8px 10px" />
        <button class="btn" type="submit">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
      </form>
    </section>

    <p class="footer">GitHub Pages + Firebase ‚Ä¢ E2E AES-GCM ‚Ä¢ –ö–∞—Ä—Ç–∏–Ω–∫–∏ –≤ Firestore ‚Ä¢ –ê–≤—Ç–æ-—É–¥–∞–ª–µ–Ω–∏–µ –ø–æ TTL</p>
  </main>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import {
      getFirestore, doc, getDoc, setDoc, addDoc, collection,
      onSnapshot, serverTimestamp, query, orderBy, where, deleteDoc, Timestamp, limit, getDocs
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDQJneytm9Zi2y0vK0i847qdeT2b_0awfA",
      authDomain: "pair-chat-7f1bf.firebaseapp.com",
      projectId: "pair-chat-7f1bf",
      storageBucket: "pair-chat-7f1bf.firebasestorage.app",
      messagingSenderId: "685488512637",
      appId: "1:685488512637:web:cb43fda988190144079b14",
      measurementId: "G-BDDLDDGP25"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db   = getFirestore(app);

    // refs
    const myCodeEl = document.getElementById("myCode");
    const copyBtn = document.getElementById("copyBtn");
    const pairForm = document.getElementById("pairForm");
    const friendCodeInput = document.getElementById("friendCodeInput");
    const pairErrorEl = document.getElementById("pairError");
    const chatSection = document.getElementById("chatSection");
    const peerCodeEl = document.getElementById("peerCode");
    const messagesEl = document.getElementById("messages");
    const msgForm = document.getElementById("msgForm");
    const msgInput = document.getElementById("msgInput");
    const imgInput = document.getElementById("imgInput");
    const wipeBtn = document.getElementById("wipeBtn");
    const closeChatBtn = document.getElementById("closeChatBtn");
    const lockStateEl = document.getElementById("lockState");
    const ttlSelect = document.getElementById("ttlSelect");
    const ttlStatus = document.getElementById("ttlStatus");

    // state
    let currentUid = null, myCode = null, currentPairId = null;
    let unsubMessages = null, unsubPair = null;
    let encKey = null;
    let ttlSeconds = 60; // default 1m

    // utils/crypto
    const te = new TextEncoder(), td = new TextDecoder();
    const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
    const rand = (n)=>crypto.getRandomValues(new Uint8Array(n));
    const bufToB64 = (b)=>btoa(String.fromCharCode(...new Uint8Array(b)));
    const b64ToBuf = (s)=>Uint8Array.from(atob(s),c=>c.charCodeAt(0)).buffer;

    const APP_SALT = "pairchat:v1";
    async function deriveKeyFromPairId(pairId){
      const baseKey = await crypto.subtle.importKey("raw", te.encode(pairId), "PBKDF2", false, ["deriveKey"]);
      return await crypto.subtle.deriveKey(
        { name:"PBKDF2", salt: te.encode(APP_SALT), iterations: 200000, hash: "SHA-256" },
        baseKey, { name:"AES-GCM", length:256 }, false, ["encrypt","decrypt"]
      );
    }
    async function encryptBytes(buf){
      const iv = rand(12);
      const ct = await crypto.subtle.encrypt({name:"AES-GCM", iv}, encKey, buf);
      return { ct:new Uint8Array(ct), iv:new Uint8Array(iv.buffer) };
    }
    async function decryptBytes(ctU8, ivU8){
      const pt = await crypto.subtle.decrypt({name:"AES-GCM", iv:ivU8}, encKey, ctU8);
      return new Uint8Array(pt);
    }
    async function encryptString(str){
      const {ct,iv}=await encryptBytes(te.encode(str));
      return { ct:bufToB64(ct.buffer), iv:bufToB64(iv.buffer), v:1 };
    }
    async function decryptToString(ctB64, ivB64){
      const pt = await decryptBytes(new Uint8Array(b64ToBuf(ctB64)), new Uint8Array(b64ToBuf(ivB64)));
      return td.decode(pt);
    }
    function escapeHtml(s){return s.replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));}
    function renderMyCode(code){ myCodeEl.textContent = code; }
    function clearMessages(){ messagesEl.innerHTML=""; }
    function stopStreams(){ if(unsubMessages){unsubMessages();unsubMessages=null;} if(unsubPair){unsubPair();unsubPair=null;} }
    function setLock(on){ lockStateEl.textContent = on ? "üîí –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –≤–∫–ª—é—á–µ–Ω–æ" : "üîì –ù–µ—Ç —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è"; lockStateEl.className = on ? "code ok" : "code"; }
    function generateCode(){ return String(Math.floor(100000 + Math.random()*900000)); }

    // === –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π, –Ω–∞–¥—ë–∂–Ω–∞—è –¥–ª—è —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (HEIC –∏ —Ç.–ø.) ===
    async function loadImageFromFile(file){
      // 1) createImageBitmap (—Å–∞–º—ã–π —Å—Ç–∞–±–∏–ª—å–Ω—ã–π –Ω–∞ iOS 15+)
      if ('createImageBitmap' in window) {
        try {
          const bmp = await createImageBitmap(file);
          return { width:bmp.width, height:bmp.height, draw:(ctx,w,h)=>{ ctx.drawImage(bmp,0,0,w,h); bmp.close(); } };
        } catch {}
      }
      // 2) –æ–±—ã—á–Ω—ã–π <img> + blob URL
      try {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.decoding = "async";
        await new Promise((res,rej)=>{img.onload=res; img.onerror=rej; img.src=url;});
        return { width:img.width, height:img.height, draw:(ctx,w,h)=>{ ctx.drawImage(img,0,0,w,h); URL.revokeObjectURL(url); } };
      } catch {}
      // 3) FileReader dataURL (—Å–∞–º—ã–π —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π)
      const dataURL = await new Promise((res,rej)=>{ const fr=new FileReader(); fr.onerror=rej; fr.onload=()=>res(fr.result); fr.readAsDataURL(file);});
      const img2 = new Image();
      await new Promise((res,rej)=>{img2.onload=res; img2.onerror=rej; img2.src=dataURL;});
      return { width:img2.width, height:img2.height, draw:(ctx,w,h)=>ctx.drawImage(img2,0,0,w,h) };
    }

    // –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–µ —Å–∂–∞—Ç–∏–µ –¥–æ ‚âà400KB
    async function compressImageAdaptive(file,{
      targetBytes=400*1024, startMaxW=1600, startMaxH=1600,
      minMaxW=512, minMaxH=512, startQuality=0.85, minQuality=0.5
    }={}){
      const painter = await loadImageFromFile(file);
      const mk = async (maxW,maxH,q)=>{
        let {width:w,height:h}=painter;
        const k=Math.min(1,maxW/w,maxH/h); w=Math.max(1,Math.round(w*k)); h=Math.max(1,Math.round(h*k));
        const c=document.createElement('canvas'); c.width=w; c.height=h;
        const ctx=c.getContext('2d'); painter.draw(ctx,w,h);
        const blob = await new Promise(res=>c.toBlob(res,'image/webp',q));
        return blob;
      };
      let maxW=startMaxW,maxH=startMaxH,q=startQuality,best=null;
      for(let i=0;i<14;i++){
        const b=await mk(maxW,maxH,q); if(!best||b.size<best.size) best=b;
        if(b.size<=targetBytes) return new Uint8Array(await b.arrayBuffer());
        if(q>minQuality) q=Math.max(minQuality,q-0.1); else {maxW=Math.max(minMaxW,Math.floor(maxW*0.8)); maxH=Math.max(minMaxH,Math.floor(maxH*0.8));}
      }
      return new Uint8Array(await best.arrayBuffer());
    }

    function ttlLabel(sec){
      const map={60:"1 –º–∏–Ω—É—Ç–∞",1800:"30 –º–∏–Ω—É—Ç",3600:"1 —á–∞—Å",25200:"7 —á–∞—Å–æ–≤",259200:"3 –¥–Ω—è",604800:"7 –¥–Ω–µ–π"};
      return map[sec] || (sec+" c");
    }

    function addMessageItem(data){
      const { uid, ts, ct, iv, type, mime, text } = data;
      const li = document.createElement("li");
      li.className = "msg " + (uid === currentUid ? "me" : "other");
      const time = ts?.toDate ? ts.toDate() : new Date();
      const hh = String(time.getHours()).padStart(2,"0"), mm = String(time.getMinutes()).padStart(2,"0");

      if (type === "image-inline" && ct && iv) {
        (async () => {
          try {
            const pt = await decryptBytes(new Uint8Array(b64ToBuf(ct)), new Uint8Array(b64ToBuf(iv)));
            const url = URL.createObjectURL(new Blob([pt], { type: mime || "image/webp" }));
            li.innerHTML = `<div><img src="${url}" alt="img"/></div><span class="msg-time">${hh}:${mm}</span>`;
          } catch {
            li.innerHTML = `<div>üîí (–Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫—É)</div><span class="msg-time">${hh}:${mm}</span>`;
          }
        })();
      } else if (ct && iv) {
        decryptToString(ct, iv).then(t=>{
          li.innerHTML = `<div>${escapeHtml(t)}</div><span class="msg-time">${hh}:${mm}</span>`;
        }).catch(()=>{
          li.innerHTML = `<div>üîí (–Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å)</div><span class="msg-time">${hh}:${mm}</span>`;
        });
      } else if (text) {
        li.innerHTML = `<div>${escapeHtml(text)}</div><span class="msg-time">${hh}:${mm}</span>`;
      } else {
        li.innerHTML = `<div>[–ø—É—Å—Ç–æ]</div><span class="msg-time">${hh}:${mm}</span>`;
      }
      messagesEl.appendChild(li);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    async function ensureOwnCode(uid){
      const local = localStorage.getItem("pairchat_code");
      if (local) {
        const snap = await getDoc(doc(db, "codes", local));
        if (snap.exists() && snap.data().ownerUid === uid) return local;
      }
      for (let i=0;i<8;i++){
        const code = generateCode();
        try{
          await setDoc(doc(db, "codes", code), { ownerUid: uid, createdAt: serverTimestamp() });
          localStorage.setItem("pairchat_code", code);
          return code;
        }catch{ await sleep(30); }
      }
      throw new Error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –∫–æ–¥. –û–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É –ø–æ–∑–∂–µ.");
    }

    // TTL
    async function saveTTL(seconds){
      ttlSeconds = seconds;
      if (!currentPairId) return;
      await setDoc(doc(db, "pairs", currentPairId), { ttlSeconds }, { merge:true });
      ttlStatus.textContent = `–ë—É–¥–µ–º —É–¥–∞–ª—è—Ç—å —Å—Ç–∞—Ä—à–µ: ${ttlLabel(ttlSeconds)}`;
    }
    async function cleanupOldMessages(){
      if (!currentPairId || !ttlSeconds) return;
      const cutoff = Timestamp.fromMillis(Date.now() - ttlSeconds*1000);
      while (true) {
        const qOld = query(collection(db, "pairs", currentPairId, "messages"),
                           where("ts","<",cutoff), orderBy("ts","asc"), limit(50));
        const snap = await getDocs(qOld);
        if (snap.empty) break;
        await Promise.all(snap.docs.map(d=>deleteDoc(d.ref)));
        await sleep(80);
      }
    }
    setInterval(()=>cleanupOldMessages().catch(()=>{}), 60000);

    // —Å—Ç–∏—Ä–∞–Ω–∏–µ —á–∞—Ç–∞
    async function wipeChatCompletely(){
      if(!currentPairId) return;
      if(!confirm("–£–¥–∞–ª–∏—Ç—å –í–°–ï —Å–æ–æ–±—â–µ–Ω–∏—è —ç—Ç–æ–≥–æ —á–∞—Ç–∞ —É –æ–±–æ–∏—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤? –û—Ç–º–µ–Ω–∏—Ç—å –Ω–µ–ª—å–∑—è.")) return;
      while (true){
        const qBatch = query(collection(db, "pairs", currentPairId, "messages"), orderBy("ts","asc"), limit(50));
        const snap = await getDocs(qBatch);
        if (snap.empty) break;
        await Promise.all(snap.docs.map(d=>deleteDoc(d.ref)));
      }
      await deleteDoc(doc(db, "pairs", currentPairId));
      clearMessages();
      alert("–ß–∞—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—â–µ–Ω.");
    }

    async function openChatWithCode(friendCode){
      pairErrorEl.textContent = "";
      if(!/^\d{6}$/.test(friendCode)){ pairErrorEl.textContent="–í–≤–µ–¥–∏—Ç–µ 6 —Ü–∏—Ñ—Ä."; return; }
      if(friendCode === myCode){ pairErrorEl.textContent="–ù–µ–ª—å–∑—è —á–∞—Ç–∏—Ç—å—Å—è —Å —Å–æ–±–æ–π :)"; return; }

      const fsnap = await getDoc(doc(db, "codes", friendCode));
      if(!fsnap.exists()){ pairErrorEl.textContent="–ö–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–ø—Ä–æ—Å–∏—Ç–µ –¥—Ä—É–≥–∞ –æ—Ç–∫—Ä—ã—Ç—å —Å–∞–π—Ç."; return; }
      const friendUid = fsnap.data().ownerUid;
      if(friendUid === currentUid){ pairErrorEl.textContent="–≠—Ç–æ –≤–∞—à –∫–æ–¥."; return; }

      const [aUid,bUid] = [currentUid,friendUid].sort();
      currentPairId = `${aUid}_${bUid}`;

      encKey = await deriveKeyFromPairId(currentPairId);
      setLock(true);

      await setDoc(doc(db, "pairs", currentPairId), { aUid, bUid, createdAt: serverTimestamp(), ttlSeconds }, { merge:true });

      if (unsubPair) unsubPair();
      unsubPair = onSnapshot(doc(db, "pairs", currentPairId), (ds)=>{
        const data = ds.data() || {};
        if (data?.ttlSeconds && data.ttlSeconds !== ttlSeconds) {
          ttlSeconds = data.ttlSeconds;
          ttlSelect.value = String(ttlSeconds);
          ttlStatus.textContent = `–ë—É–¥–µ–º —É–¥–∞–ª—è—Ç—å —Å—Ç–∞—Ä—à–µ: ${ttlLabel(ttlSeconds)}`;
        }
      });

      if (unsubMessages) unsubMessages();
      clearMessages();
      const qMsgs = query(collection(db, "pairs", currentPairId, "messages"), orderBy("ts","asc"));
      unsubMessages = onSnapshot(qMsgs, (snap)=>{ clearMessages(); snap.forEach(d=>addMessageItem(d.data())); });

      peerCodeEl.textContent = friendCode;
      chatSection.classList.remove("hidden");
      msgInput.focus();
      cleanupOldMessages().catch(()=>{});
    }

    async function sendText(text){
      if(!text || !currentPairId) return;
      const payload = await encryptString(text);
      await addDoc(collection(db, "pairs", currentPairId, "messages"), {
        uid: currentUid, ...payload, type:"text", ts: serverTimestamp()
      });
    }
    async function sendImage(file){
      if(!file || !currentPairId) return;
      const webp = await compressImageAdaptive(file,{
        targetBytes:400*1024, startMaxW:1600, startMaxH:1600,
        minMaxW:512, minMaxH:512, startQuality:0.85, minQuality:0.5
      });
      const { ct, iv } = await encryptBytes(webp.buffer);
      await addDoc(collection(db, "pairs", currentPairId, "messages"), {
        uid: currentUid, type:"image-inline", mime:"image/webp",
        ct: bufToB64(ct.buffer), iv: bufToB64(iv.buffer), ts: serverTimestamp()
      });
      imgInput.value = "";
    }

    // –æ–¥–Ω–∞ –∫–Ω–æ–ø–∫–∞ ‚Äî –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Ç–µ–∫—Å—Ç –∏/–∏–ª–∏ —Ñ–æ—Ç–æ
    copyBtn.addEventListener("click", async ()=>{
      try{ await navigator.clipboard.writeText(myCode || ""); copyBtn.textContent="–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!"; setTimeout(()=>copyBtn.textContent="–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å",1100); }catch{}
    });
    pairForm.addEventListener("submit", async (e)=>{ e.preventDefault(); await openChatWithCode((friendCodeInput.value||"").trim()); });
    msgForm.addEventListener("submit", async (e)=>{
      e.preventDefault();
      const t = (msgInput.value||"").trim();
      const f = imgInput.files?.[0];
      if (t) { await sendText(t); msgInput.value=""; }
      if (f) { await sendImage(f); imgInput.value=""; }
    });
    ttlSelect.addEventListener("change", async ()=>{ await saveTTL(Number(ttlSelect.value)); });
    wipeBtn.addEventListener("click", async ()=>{ await wipeChatCompletely().catch(err=>alert("–û—à–∏–±–∫–∞: "+err.message)); });
    closeChatBtn.addEventListener("click", ()=>{ stopStreams(); chatSection.classList.add("hidden"); currentPairId=null; encKey=null; setLock(true); });

    onAuthStateChanged(auth, async (user)=>{
      if(!user) return;
      currentUid = user.uid;
      try{ myCode = await ensureOwnCode(currentUid); renderMyCode(myCode); }
      catch(e){ pairErrorEl.textContent = e.message || String(e); }
    });
    signInAnonymously(auth).catch(err=>{
      pairErrorEl.textContent = `Firebase Auth error: ${err.code}`;
      console.error(err);
    });

    // –¥–µ—Ñ–æ–ª—Ç TTL –≤ UI
    ttlSelect.value = "60";
    ttlStatus.textContent = `–ë—É–¥–µ–º —É–¥–∞–ª—è—Ç—å —Å—Ç–∞—Ä—à–µ: ${ttlLabel(ttlSeconds)}`;
  </script>
</body>
</html>