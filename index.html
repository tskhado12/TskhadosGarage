<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <title>Pair Chat ‚Äî E2E + Images (Firestore) + TTL</title>
  <style>
    :root { --bg:#0f1220; --card:#171a2b; --text:#eef1ff; --muted:#aab0d6;
            --accent:#5c7cfa; --accent2:#748ffc; --danger:#ff6b6b; --ok:#51cf66;
            --shadow:0 10px 30px rgba(0,0,0,.35); }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; -webkit-text-size-adjust:100%;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;
      background:
        radial-gradient(1200px 600px at 20% -10%,rgba(92,124,250,.18),transparent),
        radial-gradient(1000px 500px at 100% 0,rgba(116,143,252,.14),transparent),
        var(--bg);
      color:var(--text);
      overflow-x:hidden; /* —É–±–∏—Ä–∞–µ–º –ø–æ–ª–æ—Å—É —Å–ø—Ä–∞–≤–∞ */
    }
    .container{max-width:860px;margin:14px auto;padding:0 10px}
    h1{margin:0 0 10px}
    .card{background:var(--card);border:1px solid rgba(255,255,255,.06);border-radius:16px;padding:12px;margin:8px 0;box-shadow:var(--shadow);overflow:hidden}
    .card.compact{padding:10px}
    .hint{margin:4px 0 0;color:var(--muted);font-style:italic}
    .code{font-family:ui-monospace,Menlo,Consolas,monospace;letter-spacing:1px;font-weight:700}
    .row{display:flex;gap:8px;align-items:center}
    .row-wrap{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .my-code-row{gap:12px;font-size:22px}

    input, select, button{font-size:17px; line-height:1.2}
    input, select{
      flex:1;padding:11px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.04);color:var(--text);outline:none
    }
    input::placeholder{color:#9aa2d1}
    input:focus, select:focus{border-color:var(--accent)}
    .btn{padding:10px 14px;border-radius:12px;border:1px solid transparent;
         background:linear-gradient(180deg,var(--accent),var(--accent2));color:#fff;font-weight:600;cursor:pointer}
    .btn:hover{filter:brightness(1.1)} .btn:active{transform:translateY(1px)}
    .btn[disabled]{opacity:.7;cursor:default}
    .btn-light{background:rgba(255,255,255,.08);border-color:rgba(255,255,255,.14)}
    .btn-danger{background:rgba(255,107,107,.18);border-color:rgba(255,107,107,.45);color:#fff}
    .error{color:var(--danger);min-height:20px;margin-top:8px}
    .ok{color:var(--ok)}

    .chat-header{display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:6px;flex-wrap:wrap}
    .chat-actions{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .chat{display:grid;grid-template-rows:auto auto 1fr auto;height:74vh}
    .messages{list-style:none;padding:0;margin:0;overflow-y:auto;border:1px solid rgba(255,255,255,.08);
              border-radius:12px;background:rgba(255,255,255,.03)}
    .msg{max-width:80%;margin:8px;padding:10px 12px;border-radius:14px;line-height:1.25;
         border:1px solid rgba(255,255,255,.08);box-shadow:0 6px 14px rgba(0,0,0,.2);word-wrap:break-word}
    .msg.me{margin-left:auto;background:rgba(92,124,250,.18)}
    .msg.other{margin-right:auto;background:rgba(255,255,255,.06)}
    .msg-time{display:block;margin-top:6px;font-size:12px;color:var(--muted);text-align:right}
    .msg img{max-width:420px;border-radius:10px;display:block}
    .send-row{
      display:flex;gap:8px;margin-top:8px;position:sticky;bottom:0;z-index:2;
      background:rgba(15,18,32,.7);backdrop-filter:blur(6px);padding:8px;border-radius:12px;
      border:1px solid rgba(255,255,255,.06)
    }
    .hidden{display:none}
    .footer{text-align:center;color:var(--muted);margin-top:14px;font-size:12px}
    .small{font-size:12px;color:var(--muted)}
    .nowrap{white-space:nowrap}

    @media (max-width: 520px){
      .container{margin:12px auto}
      .card.compact h2{margin:0 0 6px;font-size:18px}
      .hint{display:none}
      .msg img{max-width:74vw}
      .send-row{flex-direction:column;align-items:stretch;padding-bottom:calc(8px + env(safe-area-inset-bottom))}
      #imgInput{width:100%}
    }
  </style>
</head>
<body>
  <main class="container">
    <h1>Pair Chat</h1>

    <section class="card compact">
      <h2>–¢–≤–æ–π –∫–æ–¥</h2>
      <div class="row my-code-row">
        <span id="myCode" class="code">‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢</span>
        <button id="copyBtn" class="btn">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
      </div>
      <p class="hint">–û—Ç–ø—Ä–∞–≤—å —ç—Ç–æ—Ç 6-–∑–Ω–∞—á–Ω—ã–π –∫–æ–¥ –¥—Ä—É–≥—É. –ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —á–∞—Ç, –≤–≤–µ–¥–∏ –µ–≥–æ –∫–æ–¥ –Ω–∏–∂–µ.</p>
    </section>

    <section class="card compact">
      <h2>–ù–∞—á–∞—Ç—å —á–∞—Ç —Å –¥—Ä—É–≥–æ–º</h2>
      <form id="pairForm" class="row">
        <input id="friendCodeInput" maxlength="6" pattern="[0-9]{6}" placeholder="–ö–æ–¥ –¥—Ä—É–≥–∞ (6 —Ü–∏—Ñ—Ä)" required />
        <button class="btn" type="submit">–û—Ç–∫—Ä—ã—Ç—å —á–∞—Ç</button>
      </form>
      <p id="pairError" class="error"></p>
    </section>

    <section id="chatSection" class="card chat hidden">
      <div class="chat-header">
        <div>–ß–∞—Ç —Å –∫–æ–¥–æ–º: <span id="peerCode" class="code"></span></div>
        <div class="chat-actions">
          <div id="lockState" class="code ok">üîí –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –≤–∫–ª—é—á–µ–Ω–æ</div>
          <button id="wipeBtn" class="btn btn-danger">–°—Ç–µ—Ä–µ—Ç—å –≤—Å—ë</button>
          <button id="closeChatBtn" class="btn btn-light">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
      </div>

      <div class="row-wrap" style="margin-bottom:6px">
        <label class="small nowrap" for="ttlSelect">–£–¥–∞–ª—è—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è —á–µ—Ä–µ–∑:</label>
        <select id="ttlSelect" style="max-width:260px">
          <option value="60" selected>1 –º–∏–Ω—É—Ç–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)</option>
          <option value="1800">30 –º–∏–Ω—É—Ç</option>
          <option value="3600">1 —á–∞—Å</option>
          <option value="25200">7 —á–∞—Å–æ–≤</option>
          <option value="259200">3 –¥–Ω—è</option>
          <option value="604800">7 –¥–Ω–µ–π</option>
        </select>
        <span id="ttlStatus" class="small"></span>
      </div>

      <ul id="messages" class="messages"></ul>

      <form id="msgForm" class="send-row">
        <input id="msgInput" placeholder="–ù–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ..." autocomplete="off" />
        <input id="imgInput" type="file" accept="image/*;capture=camera"
               style="flex:0 0 auto;width:100%;padding:8px 10px" />
        <button id="sendBtn" class="btn" type="submit">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
      </form>
    </section>

    <p class="footer">GitHub Pages + Firebase ‚Ä¢ E2E AES-GCM ‚Ä¢ –ö–∞—Ä—Ç–∏–Ω–∫–∏ –≤ Firestore ‚Ä¢ –ê–≤—Ç–æ-—É–¥–∞–ª–µ–Ω–∏–µ –ø–æ TTL</p>
  </main>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import {
      getFirestore, doc, getDoc, setDoc, addDoc, collection,
      onSnapshot, serverTimestamp, query, orderBy, where, deleteDoc, Timestamp, limit, getDocs
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDQJneytm9Zi2y0vK0i847qdeT2b_0awfA",
      authDomain: "pair-chat-7f1bf.firebaseapp.com",
      projectId: "pair-chat-7f1bf",
      storageBucket: "pair-chat-7f1bf.firebasestorage.app",
      messagingSenderId: "685488512637",
      appId: "1:685488512637:web:cb43fda988190144079b14",
      measurementId: "G-BDDLDDGP25"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db   = getFirestore(app);

    // refs
    const myCodeEl = document.getElementById("myCode");
    const copyBtn = document.getElementById("copyBtn");
    const pairForm = document.getElementById("pairForm");
    const friendCodeInput = document.getElementById("friendCodeInput");
    const pairErrorEl = document.getElementById("pairError");
    const chatSection = document.getElementById("chatSection");
    const peerCodeEl = document.getElementById("peerCode");
    const messagesEl = document.getElementById("messages");
    const msgForm = document.getElementById("msgForm");
    const msgInput = document.getElementById("msgInput");
    const imgInput = document.getElementById("imgInput");
    const sendBtn = document.getElementById("sendBtn");
    const wipeBtn = document.getElementById("wipeBtn");
    const closeChatBtn = document.getElementById("closeChatBtn");
    const lockStateEl = document.getElementById("lockState");
    const ttlSelect = document.getElementById("ttlSelect");
    const ttlStatus = document.getElementById("ttlStatus");

    // state
    let currentUid = null, myCode = null, currentPairId = null;
    let unsubMessages = null, unsubPair = null;
    let encKey = null;
    let ttlSeconds = 60;

    // utils/crypto
    const te = new TextEncoder(), td = new TextDecoder();
    const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
    const rand = (n)=>crypto.getRandomValues(new Uint8Array(n));
    const bufToB64 = (b)=>btoa(String.fromCharCode(...new Uint8Array(b)));
    const b64ToBuf = (s)=>Uint8Array.from(atob(s),c=>c.charCodeAt(0)).buffer;

    const APP_SALT = "pairchat:v1";
    async function deriveKeyFromPairId(pairId){
      const baseKey = await crypto.subtle.importKey("raw", te.encode(pairId), "PBKDF2", false, ["deriveKey"]);
      return await crypto.subtle.deriveKey(
        { name:"PBKDF2", salt: te.encode(APP_SALT), iterations: 200000, hash: "SHA-256" },
        baseKey, { name:"AES-GCM", length:256 }, false, ["encrypt","decrypt"]
      );
    }
    async function encryptBytes(buf){
      const iv = rand(12);
      const ct = await crypto.subtle.encrypt({name:"AES-GCM", iv}, encKey, buf);
      return { ct:new Uint8Array(ct), iv:new Uint8Array(iv.buffer) };
    }
    async function decryptBytes(ctU8, ivU8){
      const pt = await crypto.subtle.decrypt({name:"AES-GCM", iv:ivU8}, encKey, ctU8);
      return new Uint8Array(pt);
    }
    async function encryptString(str){
      const {ct,iv}=await encryptBytes(te.encode(str));
      return { ct:bufToB64(ct.buffer), iv:bufToB64(iv.buffer), v:1 };
    }
    async function decryptToString(ctB64, ivB64){
      const pt = await decryptBytes(new Uint8Array(b64ToBuf(ctB64)), new Uint8Array(b64ToBuf(ivB64)));
      return td.decode(pt);
    }
    function escapeHtml(s){return s.replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));}
    function renderMyCode(code){ myCodeEl.textContent = code; }
    function generateCode(){ return String(Math.floor(100000 + Math.random()*900000)); }

    // --- –ù–∞–¥—ë–∂–Ω–æ–µ —Å–∂–∞—Ç–∏–µ –¥–ª—è iPhone: –≤—Å–µ–≥–¥–∞ JPEG —á–µ—Ä–µ–∑ FileReader ---
    async function readAsDataURL(file){
      return await new Promise((res,rej)=>{const fr=new FileReader(); fr.onerror=rej; fr.onload=()=>res(fr.result); fr.readAsDataURL(file);});
    }
    async function compressToJpegBytes(file,{
      targetBytes=320*1024, startMaxW=1600, startMaxH=1600,
      minMaxW=320, minMaxH=320, startQuality=0.85, minQuality=0.5
    }={}){
      const dataURL = await readAsDataURL(file);
      const img = new Image(); img.decoding="async";
      await new Promise((res,rej)=>{img.onload=res; img.onerror=rej; img.src=dataURL;});
      let maxW=startMaxW, maxH=startMaxH, q=startQuality, best=null;
      const make = async ()=>{
        let w=img.width, h=img.height, k=Math.min(1,maxW/w,maxH/h);
        w=Math.max(1,Math.round(w*k)); h=Math.max(1,Math.round(h*k));
        const c=document.createElement('canvas'); c.width=w; c.height=h;
        c.getContext('2d').drawImage(img,0,0,w,h);
        return await new Promise(res=>c.toBlob(res,'image/jpeg',q));
      };
      for(let i=0;i<24;i++){
        const blob = await make(); if(!best || blob.size<best.size) best=blob;
        if(blob.size<=targetBytes) return { bytes:new Uint8Array(await blob.arrayBuffer()), mime:'image/jpeg' };
        if(q>minQuality) q=Math.max(minQuality,q-0.1);
        else { maxW=Math.max(minMaxW,Math.floor(maxW*0.75)); maxH=Math.max(minMaxH,Math.floor(maxH*0.75)); }
      }
      return { bytes:new Uint8Array(await best.arrayBuffer()), mime:'image/jpeg' };
    }

    function ttlLabel(sec){
      const map={60:"1 –º–∏–Ω—É—Ç–∞",1800:"30 –º–∏–Ω—É—Ç",3600:"1 —á–∞—Å",25200:"7 —á–∞—Å–æ–≤",259200:"3 –¥–Ω—è",604800:"7 –¥–Ω–µ–π"};
      return map[sec] || (sec+" c");
    }

    function addMessageItem(data){
      const { uid, ts, ct, iv, type, mime, text } = data;
      const li = document.createElement("li");
      li.className = "msg " + (uid === currentUid ? "me" : "other");
      const time = ts?.toDate ? ts.toDate() : new Date();
      const hh = String(time.getHours()).padStart(2,"0"), mm = String(time.getMinutes()).padStart(2,"0");

      if (type === "image-inline" && ct && iv) {
        (async () => {
          try {
            const pt = await decryptBytes(new Uint8Array(b64ToBuf(ct)), new Uint8Array(b64ToBuf(iv)));
            const url = URL.createObjectURL(new Blob([pt], { type: mime || "image/jpeg" }));
            li.innerHTML = `<div><img src="${url}" alt="img"/></div><span class="msg-time">${hh}:${mm}</span>`;
          } catch {
            li.innerHTML = `<div>üîí (–Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫—É)</div><span class="msg-time">${hh}:${mm}</span>`;
          }
        })();
      } else if (ct && iv) {
        decryptToString(ct, iv).then(t=>{
          li.innerHTML = `<div>${escapeHtml(t)}</div><span class="msg-time">${hh}:${mm}</span>`;
        }).catch(()=>{
          li.innerHTML = `<div>üîí (–Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å)</div><span class="msg-time">${hh}:${mm}</span>`;
        });
      } else if (text) {
        li.innerHTML = `<div>${escapeHtml(text)}</div><span class="msg-time">${hh}:${mm}</span>`;
      } else {
        li.innerHTML = `<div>[–ø—É—Å—Ç–æ]</div><span class="msg-time">${hh}:${mm}</span>`;
      }
      messagesEl.appendChild(li);
      // –∞–≤—Ç–æ—Å–∫—Ä–æ–ª –≤–Ω–∏–∑ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ—á—Ç–∏ –≤–Ω–∏–∑—É
      const nearBottom = (messagesEl.scrollTop + messagesEl.clientHeight) >= (messagesEl.scrollHeight - 120);
      if (nearBottom) messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    async function ensureOwnCode(uid){
      const local = localStorage.getItem("pairchat_code");
      if (local) {
        const snap = await getDoc(doc(db, "codes", local));
        if (snap.exists() && snap.data().ownerUid === uid) return local;
      }
      for (let i=0;i<8;i++){
        const code = generateCode();
        try{
          await setDoc(doc(db, "codes", code), { ownerUid: uid, createdAt: serverTimestamp() });
          localStorage.setItem("pairchat_code", code);
          return code;
        }catch{ await sleep(30); }
      }
      throw new Error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –∫–æ–¥. –û–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É –ø–æ–∑–∂–µ.");
    }

    // TTL / –æ—á–∏—Å—Ç–∫–∞
    async function saveTTL(seconds){
      ttlSeconds = seconds;
      if (!currentPairId) return;
      await setDoc(doc(db, "pairs", currentPairId), { ttlSeconds }, { merge:true });
      ttlStatus.textContent = `–ë—É–¥–µ–º —É–¥–∞–ª—è—Ç—å —Å—Ç–∞—Ä—à–µ: ${ttlLabel(ttlSeconds)}`;
    }
    async function cleanupOldMessages(){
      if (!currentPairId || !ttlSeconds) return;
      const cutoff = Timestamp.fromMillis(Date.now() - ttlSeconds*1000);
      while (true) {
        const qOld = query(collection(db, "pairs", currentPairId, "messages"),
                           where("ts","<",cutoff), orderBy("ts","asc"), limit(50));
        const snap = await getDocs(qOld);
        if (snap.empty) break;
        await Promise.all(snap.docs.map(d=>deleteDoc(d.ref)));
        await sleep(80);
      }
    }
    setInterval(()=>cleanupOldMessages().catch(()=>{}), 60000);

    async function wipeChatCompletely(){
      if(!currentPairId) return;
      if(!confirm("–£–¥–∞–ª–∏—Ç—å –í–°–ï —Å–æ–æ–±—â–µ–Ω–∏—è —ç—Ç–æ–≥–æ —á–∞—Ç–∞ —É –æ–±–æ–∏—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤? –û—Ç–º–µ–Ω–∏—Ç—å –Ω–µ–ª—å–∑—è.")) return;
      while (true){
        const qBatch = query(collection(db, "pairs", currentPairId, "messages"), orderBy("ts","asc"), limit(50));
        const snap = await getDocs(qBatch);
        if (snap.empty) break;
        await Promise.all(snap.docs.map(d=>deleteDoc(d.ref)));
      }
      await deleteDoc(doc(db, "pairs", currentPairId));
      messagesEl.innerHTML="";
      alert("–ß–∞—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—â–µ–Ω.");
    }

    async function openChatWithCode(friendCode){
      pairErrorEl.textContent = "";
      if(!/^\d{6}$/.test(friendCode)){ pairErrorEl.textContent="–í–≤–µ–¥–∏—Ç–µ 6 —Ü–∏—Ñ—Ä."; return; }
      if(friendCode === myCode){ pairErrorEl.textContent="–ù–µ–ª—å–∑—è —á–∞—Ç–∏—Ç—å—Å—è —Å —Å–æ–±–æ–π :)"; return; }

      const fsnap = await getDoc(doc(db, "codes", friendCode));
      if(!fsnap.exists()){ pairErrorEl.textContent="–ö–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–ø—Ä–æ—Å–∏—Ç–µ –¥—Ä—É–≥–∞ –æ—Ç–∫—Ä—ã—Ç—å —Å–∞–π—Ç."; return; }
      const friendUid = fsnap.data().ownerUid;
      if(friendUid === currentUid){ pairErrorEl.textContent="–≠—Ç–æ –≤–∞—à –∫–æ–¥."; return; }

      const [aUid,bUid] = [currentUid,friendUid].sort();
      currentPairId = `${aUid}_${bUid}`;

      encKey = await deriveKeyFromPairId(currentPairId);
      setLock(true);

      await setDoc(doc(db, "pairs", currentPairId), { aUid, bUid, createdAt: serverTimestamp(), ttlSeconds }, { merge:true });

      if (unsubPair) unsubPair();
      unsubPair = onSnapshot(doc(db, "pairs", currentPairId), (ds)=>{
        const data = ds.data() || {};
        if (data?.ttlSeconds && data.ttlSeconds !== ttlSeconds) {
          ttlSeconds = data.ttlSeconds;
          ttlSelect.value = String(ttlSeconds);
          ttlStatus.textContent = `–ë—É–¥–µ–º —É–¥–∞–ª—è—Ç—å —Å—Ç–∞—Ä—à–µ: ${ttlLabel(ttlSeconds)}`;
        }
      });

      if (unsubMessages) unsubMessages();
      messagesEl.innerHTML="";
      const qMsgs = query(collection(db, "pairs", currentPairId, "messages"), orderBy("ts","asc"));
      // –í–ê–ñ–ù–û: –Ω–µ –æ—á–∏—â–∞–µ–º –≤–µ—Å—å —Å–ø–∏—Å–æ–∫ –Ω–∞ –∫–∞–∂–¥—ã–π —Å–Ω–∞–ø—à–æ—Ç ‚Äî –¥–æ–±–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –Ω–æ–≤—ã–µ
      unsubMessages = onSnapshot(qMsgs, (snap)=>{
        snap.docChanges().forEach(ch=>{
          if (ch.type === "added") addMessageItem(ch.doc.data());
          // (–∏–∑–º–µ–Ω–µ–Ω–∏—è/—É–¥–∞–ª–µ–Ω–∏—è –Ω–∞–º –Ω–µ –Ω—É–∂–Ω—ã –¥–ª—è —á–∞—Ç–∞)
        });
      });

      peerCodeEl.textContent = friendCode;
      chatSection.classList.remove("hidden");
      msgInput.focus();
      cleanupOldMessages().catch(()=>{});
    }

    async function sendText(text){
      if(!text || !currentPairId) return;
      const payload = await encryptString(text);
      await addDoc(collection(db, "pairs", currentPairId, "messages"), {
        uid: currentUid, ...payload, type:"text", ts: serverTimestamp()
      });
    }

    async function sendImage(file){
      if(!file || !currentPairId) return;
      try{
        const { bytes, mime } = await compressToJpegBytes(file,{
          targetBytes:320*1024, startMaxW:1600, startMaxH:1600,
          minMaxW:320, minMaxH:320, startQuality:0.85, minQuality:0.5
        });
        const { ct, iv } = await encryptBytes(bytes.buffer);
        await addDoc(collection(db, "pairs", currentPairId, "messages"), {
          uid: currentUid, type:"image-inline", mime,
          ct: bufToB64(ct.buffer), iv: bufToB64(iv.buffer), ts: serverTimestamp()
        });
        imgInput.value = "";
      }catch(err){
        console.error(err);
        pairErrorEl.textContent = "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ: " + (err.message || err);
      }
    }

    // events
    copyBtn.addEventListener("click", async ()=>{
      try{ await navigator.clipboard.writeText(myCode || ""); copyBtn.textContent="–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!"; setTimeout(()=>copyBtn.textContent="–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å",1100); }catch{}
    });
    pairForm.addEventListener("submit", async (e)=>{ e.preventDefault(); await openChatWithCode((friendCodeInput.value||"").trim()); });

    msgForm.addEventListener("submit", async (e)=>{
      e.preventDefault();
      sendBtn.disabled = true; const old = sendBtn.textContent; sendBtn.textContent = "–û—Ç–ø—Ä–∞–≤–∫–∞‚Ä¶";
      try{
        const t = (msgInput.value||"").trim();
        const f = imgInput.files?.[0];
        if (t) { await sendText(t); msgInput.value=""; }
        if (f) { await sendImage(f); }
      } finally {
        sendBtn.disabled = false; sendBtn.textContent = old;
      }
    });

    ttlSelect.addEventListener("change", async ()=>{ await saveTTL(Number(ttlSelect.value)); });
    wipeBtn.addEventListener("click", async ()=>{ await wipeChatCompletely().catch(err=>alert("–û—à–∏–±–∫–∞: "+err.message)); });
    closeChatBtn.addEventListener("click", ()=>{ if(unsubMessages)unsubMessages(); if(unsubPair)unsubPair(); chatSection.classList.add("hidden"); currentPairId=null; encKey=null; });

    onAuthStateChanged(auth, async (user)=>{
      if(!user) return;
      currentUid = user.uid;
      try{ myCode = await ensureOwnCode(currentUid); renderMyCode(myCode); }
      catch(e){ pairErrorEl.textContent = e.message || String(e); }
    });
    signInAnonymously(auth).catch(err=>{
      pairErrorEl.textContent = `Firebase Auth error: ${err.code}`;
      console.error(err);
    });

    // –¥–µ—Ñ–æ–ª—Ç TTL –≤ UI
    ttlSelect.value = "60";
    ttlStatus.textContent = `–ë—É–¥–µ–º —É–¥–∞–ª—è—Ç—å —Å—Ç–∞—Ä—à–µ: ${ttlLabel(ttlSeconds)}`;
  </script>
</body>
</html>